#include "taylor.h"

/***********************************************************************
 *
 * Code generated by the TAYLOR translator.
 */

#define ND 2




static int (*user_defined_order_function)(double, double, double);
static double (*user_defined_stepsize_function)(MY_FLOAT **, int, int, double, double, double);


/*
next line defines the largest power of 2 such that 2^(LEXP2) and
2^(-LEXP2) do not overflow/underflow the double arithmetic of your
computer.
*/
#define LEXP2 1023 /* Maorong: this is ok for Intel, do you know if this is also the IEEE standard? */

#define DEBUG_LEVEL 0 /* to print some internal information */

int taylor_step_perturbation(MY_FLOAT *ti,
                 MY_FLOAT *x,
                 int      dir,
                 int      step_ctl,
                 double   log10abserr,
                 double   log10relerr,
                 MY_FLOAT *endtime,
                 MY_FLOAT *ht,
                 int      *order)
/*
 * single integration step with taylor method. the parameters are:
 *
 * ti: on input:  time of the initial condition
 *     on output: new time
 *
 * x:  on input:  initial condition
 *     on output: new condition, corresponding to the (output) time ti
 *
 * dir: flag to integrate forward or backwards.
 *     1: forward
 *    -1: backwards
 *     WARNING: this flag is ignored if step_ctl (see below) is set to 0.
 *
 * step_ctl: flag for the step size control. the possible values are:
 *     0: no step size control, so the step and order are provided by
 *        the user. the parameter ht is used as step, and the parameter
 *        order (see below) is used as the order.
 *     1: standard stepsize control. it uses an approximation to the
 *        optimal order and to the radius of convergence of the series
 *        to approximate the 'optimal' step size. It tries to keep the
 *        absolute and relative errors below the given values. See the
 *        paper for more details.
 *     2: as 1, but adding an extra condition on the stepsize h: the
 *        terms of the series --after being multiplied by the suitable
 *        power of h-- cannot grow.
 *     3: as 2, but using double variables for the norms of the
 *        normalized derivatives. this version is faster than 2 but,
 *        if the order of the taylor method is very high and (some of)
 *        these derivatives are outside the range of a double
 *        variable, it could produce over/underflow problems.
 *        so, the moral is:
 *        a) if you are working with the standard double precision
 *          arithmetic (i.e., MY_FLOAT is defined as double), it
 *          does not matter if you use step_ctl 2 or 3 (they are
 *          exactly the same).
 *        b) if you are using an arithmetic of moderate precision
 *          (like doubledouble, quad-double or gmp with 100 digits or
 *          so), and you want to use the step size method corresponding
 *          to step_ctl 2, you can try to set step_ctl to 3, to obtain a
 *          faster code. if setting this parameter to 3 results in
 *          overflows or underflows (you should see NaNs in the output
 *          of the routine), set it to 2.
 *        c) if you are using high accuracy (i.e., working with gmp
 *          with an accuracy of several hundreds --or thousands-- of
 *          decimal digits) you should select step_ctl=2
 *     4: user defined stepsize control. the code has to be included
 *        in the routine compute_timestep_user_defined (you can find
 *        this routine below). The user should also provide code for
 *        the selection of degree (see the function
 *        compute_order_user_defined below).
 *
 * log10abserr: decimal log of the absolute accuracy required.
 *
 * log10relerr: decimal log of the relative accuracy required.
 *
 * endtime: if NULL, it does nothing. if step_ctl (see above) is set
 *     to 0, it is also ignored. otherwise, if next step is outside
 *     endtime, reduce the step size so that the new time ti is
 *     exactly endtime (in that case, the function returns 1).
 *
 * ht: on input:  ignored/used as a time step (see parameter step_ctl)
 *     on output: time step used
 *
 * order: degree of the taylor expansion.
 *        input: this parameter is only used if step_ctl is 0,
 *               or if you add the code for the case step_ctl=3.
 *               its possible values are:
 *               < 2: the program will select degree 2 (if step_ctl is 0).
 *               >=2: the program will use this degree (if step_ctl is 0).
 *        ouput: degree used.
 *
 * return value:
 * 0: ok.
 * 1: ok, and ti=endtime.
 */
{
  MY_FLOAT **taylor_coefficients_perturbation(MY_FLOAT, MY_FLOAT*, int);
  MY_FLOAT **taylor_coefficients_perturbationA(MY_FLOAT, MY_FLOAT*, int, int);
  int compute_order_1_perturbation(double, double, double);
  int comp_order_other_perturbation(double, double, double);
  double compute_stepsize_1_perturbation(MY_FLOAT**, int, double, double, double);
  double compute_stepsize_2_perturbation(MY_FLOAT**, int, double, double, double);
  double compute_stepsize_3_perturbation(MY_FLOAT**, int, double, double, double);
  double comp_stepsize_other_perturbation(MY_FLOAT**, int, int, double, double, double);

  static MY_FLOAT **s,h,mtmp;
  double xi,xnorm,dxnorm,lnxnorm,dh;
  int i,j,k,nt,flag_endtime;
  static int init=0;

  if (init == 0) /* initialization of MY_FLOAT variables */
    {
      init=1;
      InitMyFloat(h);
      InitMyFloat(mtmp);
    }
/*
  log of the sup norm of the initial condition and the vectorfield.
*/
  if (step_ctl != 0)
    {
      xnorm=0;
      for (i=0; i<ND; i++)
      {
	MyFloatToDouble(xi,x[i]);
	xi=fabs(xi);
	if (xi > xnorm) xnorm=xi;
      }
      s=taylor_coefficients_perturbation(*ti,x,1); /* computation of the vector field */
      dxnorm=0;
      for (i=0; i<ND; i++)
      {
	MyFloatToDouble(xi,s[i][1]);
	xi=fabs(xi);
	if (xi > dxnorm) dxnorm=xi;
      }
      if (xnorm < dxnorm) xnorm=dxnorm;
/*
  if xnorm is zero, then we are at the origin, that is also an
  equilibrium point. so, the step size is irrelevant...
*/
      lnxnorm=(xnorm==(double)0.0)? (double) 1 : log(xnorm);
    }
    else
    {
      lnxnorm=0;
    }
/*
  we determine the degree of the taylor expansion.
  this value will be stored in the variable nt.
*/
  switch(step_ctl)
    {
    case 0: /* no step size control, fixed degree; both given by the user */
      nt=(*order<2)? 2: *order; /* 2 is the minimum order allowed */
      break;
    case 1:
      nt=compute_order_1_perturbation(lnxnorm,log10abserr,log10relerr);
      break;
    case 2:
      nt=compute_order_1_perturbation(lnxnorm,log10abserr,log10relerr);
      break;
    case 3:
      nt=compute_order_1_perturbation(lnxnorm,log10abserr,log10relerr);
      break;
    case 4:
      nt=comp_order_other_perturbation(lnxnorm,log10abserr,log10relerr);
      break;
    default:
      fprintf(stderr, "taylor_step: undefined step size control.\n");
      fprintf(stderr, "you must choose an existing step size control\n");
      fprintf(stderr, "method or supply a step size control procedure.\n");
      exit(0);
    }
  *order=nt;
/*
  computation of the jet of derivatives up to order nt
*/
  if(step_ctl != 0) {
    s=taylor_coefficients_perturbationA(*ti,x,nt,1);
  } else {
    s=taylor_coefficients_perturbation(*ti,x,nt); /* Maorong: this function has
                                             already been called (with
                                             nt=1), can we take
                                             advantage of this? */
 }

/*
  selection of the routine to compute the time step. the value
  step_ctl=4 has been reserved for the user, in case she/he wants to
  code a different method.
*/
  switch(step_ctl)
    {
    case 0: /* no step size control (fixed step size, given by the user) */
      AssignMyFloat(h,*ht);
      break;
    case 1:
      dh=compute_stepsize_1_perturbation(s,nt,lnxnorm,log10abserr,log10relerr);
      MakeMyFloatA(h, dh);
      break;
    case 2:
      dh=compute_stepsize_2_perturbation(s,nt,lnxnorm,log10abserr,log10relerr);
      MakeMyFloatA(h, dh);
      break;
    case 3:
      dh=compute_stepsize_3_perturbation(s,nt,lnxnorm,log10abserr,log10relerr);
      MakeMyFloatA(h, dh);
      break;
    case 4:
      dh=comp_stepsize_other_perturbation(s,ND,nt,lnxnorm,log10abserr,log10relerr);
      MakeMyFloatA(h, dh);
      break;
    default:
      fprintf(stderr, "taylor_step: undefined step size control.\n");
      fprintf(stderr, "You must choose an existing step size control\n");
      fprintf(stderr, "method or supply a step size control procedure.\n");
      exit(0);
    }
/*
  if step_ctl != 0, we adjust the sign of the computed stepsize.
*/
  flag_endtime=0;
  if (step_ctl != 0)
    {
      if (dir == -1) { NegateMyFloatA(h,h);} /* Maorong: is that ok? (I want to do h=-h) */
/*
      we compare *ti+h with endtime. we modify h if necessary.
*/
      if (endtime != NULL)
        {
          AddMyFloatA(mtmp,h,*ti);
          if (dir == 1) /* time goes forward */
            {
              if (MyFloatA_GE_B(mtmp,*endtime))
                {
                  SubstractMyFloatA(h,*endtime,*ti);
                  flag_endtime=1;
                }
            }
            else /* time goes backwards */
            {
              if (MyFloatA_GE_B(*endtime,mtmp))
                {
                  SubstractMyFloatA(h,*endtime,*ti);
                  flag_endtime=1;
                }
            }
        }
    }
/*
  next lines are the summation of the taylor series (horner's method)
*/
  j=nt-1;
  for(i=0; i<ND; i++) {AssignMyFloat(x[i],s[i][nt]);}
  for(k=j; k>=0; k--)
  {
    for(i=0; i<ND; i++)
    {
      MultiplyMyFloatA(mtmp, h, x[i]);
      AddMyFloatA(x[i], mtmp, s[i][k]);
    }
  }
/*
  finally, we set the values of the parameters *ht and *ti.
*/
  AssignMyFloat(*ht,h);
  if (flag_endtime == 0)
    {
      AssignMyFloat(mtmp, *ti);
      AddMyFloatA(*ti, mtmp, h);
    }
    else
    {
      AssignMyFloat(*ti,*endtime);
    }
  return(flag_endtime);
}
int compute_order_1_perturbation(double lnxnorm, double log10abserr, double log10relerr)
/*
 * this is to determine the 'optimal' degree of the taylor expansion.
 *
 * parameters:
 * lnxnorm: natural log of the norm of the initial condition
 * log10abserr: base-10 log of the absolute error required
 * log10relerr: base-10 log of the relative error required
 *
 * returned value: 'optimal' degree.
*/
{
  double log10eps,lneps;
  int nt;
  static double old_log10eps=0;
  static int old_nt=0;

  log10eps=log10abserr-(0.43429448190325182765)*lnxnorm;
  if (log10relerr < log10eps) log10eps=log10relerr;

  if (log10eps != old_log10eps)
    {
      lneps=(2.30258509299404568402)*log10eps;
      nt=(int)(-0.5*lneps+1.5);
      if (nt < 2) nt=2; /* this is the minimum order accepted */
      old_nt=nt;
#if DEBUG_LEVEL > 0
      fprintf(stderr, "taylor_step: order is %d\n",nt);
#endif
    }
    else
    {
      nt=old_nt;
    }
  return(nt);
}
double compute_stepsize_1_perturbation(MY_FLOAT **s, int nt, double lxnorm, double log10abserr, double log10relerr)
/*
 * it looks for a step size to keep the truncation error (both absolute and
 * relative) below the absolute error tol. the estimation of the error is
 * done by simply looking at the last two terms of the taylor expansion.
 */
{
  double double_log_MyFloat(MY_FLOAT x);
  static MY_FLOAT z,v1,v2,h;
  static MY_FLOAT of,uf;
  double lnv1,lnv2,r,lnro1,lnro2,lnro;
  int i;
  static int init=0;

  if (init == 0)
    {
      init=1;
      InitMyFloat(z);
      InitMyFloat(v1);
      InitMyFloat(v2);
      InitMyFloat(h);
      InitMyFloat(of);
      InitMyFloat(uf);

      r=pow((double)2,(double)LEXP2);
      MakeMyFloatA(of,r);
      r=pow((double)2,(double)(-LEXP2));
      MakeMyFloatA(uf,r);
    }
/*
  we compute the sup norm of the last two coefficients of the taylor
  series, and we store them into v1 and v2.
*/
  fabsMyFloatA(v1,s[0][nt-1]);
  fabsMyFloatA(v2,s[0][nt]);
  for(i=1; i<ND; i++)
  {
    fabsMyFloatA(z,s[i][nt-1]);
    if (MyFloatA_GT_B(z,v1)) AssignMyFloat(v1,z);
    fabsMyFloatA(z,s[i][nt]);
    if (MyFloatA_GT_B(z,v2)) AssignMyFloat(v2,z);
  }
/*
  computation of the step size. we need the logs of v1 and v2, in
  double precision (there is no need for using extended precision
  here). the idea is to assign these variables to double variables and
  then to use the standard log function. before doing that, we have to
  be sure that v1 can be assigned to a double without under or
  overflow. for this reason we will check for this condition and, if
  it fails, we will call an specific function for this case.
*/
  if (MyFloatA_LE_B(v1,of) && MyFloatA_GE_B(v1,uf))
    {
      MyFloatToDouble(r,v1);
      lnv1=log(r);
    }
    else
    {
      lnv1=double_log_MyFloat(v1);
    }
  if (MyFloatA_LE_B(v2,of) && MyFloatA_GE_B(v2,uf))
    {
      MyFloatToDouble(r,v2);
      lnv2=log(r);
    }
    else
    {
      lnv2=double_log_MyFloat(v2);
    }
  r=(lxnorm<(double)0)? lxnorm: (double)0;
  lnro1=(r-lnv1)/(nt-1);
  lnro2=(r-lnv2)/nt;
  lnro=(lnro1 < lnro2)? lnro1: lnro2;
  r=0.99*exp(lnro-2); /* 0.99 is a security factor */
  return(r);
}
double compute_stepsize_2_perturbation(MY_FLOAT **s, int nt, double lxnorm, double log10abserr, double log10relerr)
/*
 * it looks for a step size to keep the truncation error (both
 * absolute and relative) below the absolute error tol, and also tries
 * to reduce cancellations of big terms in the summation of the taylor
 * series.
 *
 * WARNING: there are two versions of this function. this is the one
 * that uses MY_FLOAT variables for all the computations
 * */
{
  double compute_stepsize_1_perturbation(MY_FLOAT**, int, double, double, double);
  static MY_FLOAT h,hj,r,z,a;
  static MY_FLOAT *norms;
  double zero=(double)0.0,c,rtmp,dh;
  int i,j;
  static int init=0,ntmax=-1;

  if (init == 0)
    {
      init=1;
      InitMyFloat(h); /* Maorong: is that ok? later I'll do
                         h=compute_stepsize_1_perturbation(...), so may be I'm
                         doing the InitMyFloat twice */
      InitMyFloat(hj);
      InitMyFloat(r);
      InitMyFloat(z);
      InitMyFloat(a);
    }
/*
  we will use the array norms to store the norms of the normalized
  derivatives
*/
  if (ntmax == -1)
    {
      ntmax=nt;
      norms=(MY_FLOAT*)malloc((ntmax+1)*sizeof(MY_FLOAT));
      if (norms == NULL) {puts("compute_stepsize_2: error 1"); exit(1);}
      for (j=0; j<=ntmax; j++) InitMyFloat(norms[i]);
    }
  if (ntmax < nt)
    {
      for (j=0; j<=ntmax; j++) ClearMyFloat(norms[i]);
      free(norms);
      ntmax=nt;
      norms=(MY_FLOAT*)malloc((ntmax+1)*sizeof(MY_FLOAT));
      if (norms == NULL) {puts("compute_stepsize_2: error 2"); exit(1);}
      for (j=0; j<=ntmax; j++) InitMyFloat(norms[i]);
    }
/*
  we compute the step size according to the first algorithm
*/
  dh=compute_stepsize_1_perturbation(s,nt,lxnorm,log10abserr,log10relerr);
  MakeMyFloatA(h,dh);
/*
  we compute the norms of the taylor coefficients
*/
  for (j=0; j<=nt; j++)
  {
    MakeMyFloatA(r,zero); /* Maorong: is that ok? I did InitMyFloat(r) before */
    for (i=0; i<ND; i++)
    {
      fabsMyFloatA(a,s[i][j]);
      if (MyFloatA_GT_B(a,r)) AssignMyFloat(r,a);
    }
    AssignMyFloat(norms[j],r);
  }
/*
  next loop runs over the norms of the taylor coefficients, checking
  whether the summation of the taylor series (from low to high order)
  involves increasing terms. in this case, it reduces the stepsize
  accordingly.
*/
  MultiplyMyFloatA(r,h,norms[1]);
  AddMyFloatA(z,norms[0],r);

  AssignMyFloat(hj,h);

  for(j=2; j<=nt; j++)
  {
    MultiplyMyFloatA(r,h,hj); /* Maorong: I've splitted hj=hj*h in two lines, can be coded in one? */
    AssignMyFloat(hj,r);

    MultiplyMyFloatA(r,norms[j],hj);
    if (MyFloatA_LE_B(r,z)) continue;
/*
    we reduce h (and hj)
*/
    DivideMyFloatA(hj,z,norms[j]);

    DivideMyFloatA(a,r,z);
    MyFloatToDouble(c,a);
    c=pow(c,(double)1.e0/(double)j);
    MakeMyFloatA(a,c); /* Maorong: this conversion, is ok? */
    DivideMyFloatA(r,h,a);
    AssignMyFloat(h,r);

#if DEBUG_LEVEL > 1
    fprintf(stderr, "order %2d. reducing h from %14.6e to %14.6e\n",j,c*h,h);
#endif
  }

  MyFloatToDouble(rtmp,h);
  return(rtmp);
}
double compute_stepsize_3_perturbation(MY_FLOAT **s, int nt, double lxnorm, double log10abserr, double log10relerr)
/*
 * it looks for a step size to keep the truncation error (both
 * absolute and relative) below the absolute error tol, and also tries
 * to reduce cancellations of big terms in the summation of the taylor
 * series.
 *
 * WARNING: there are two versions of this function. this is the one
 * that uses double variables for the norms of the normalized
 * derivatives and related computations.
 */
{
  double compute_stepsize_1_perturbation(MY_FLOAT**, int, double, double, double);
  static MY_FLOAT h,mtmp;
  static double *norms;
  double hd,hdj,r,z,a,dh,rtmp;
  int i,j,flag;
  static int init=0,ntmax=-1;

  if (init == 0)
    {
      init=1;
      InitMyFloat(mtmp);
      InitMyFloat(h); /* Maorong: is that ok? later I'll do
                         h=compute_stepsize_1_perturbation(...), so may be I'm
                         doing the InitMyFloat twice */
    }
/*
  we will use the array norms to store the norms of the normalized
  derivatives
*/
  if (ntmax == -1)
    {
      ntmax=nt;
      norms=(double*)malloc((ntmax+1)*sizeof(double));
      if (norms == NULL) {puts("compute_stepsize_2: error 1"); exit(1);}
    }
  if (ntmax < nt)
    {
      free(norms);
      ntmax=nt;
      norms=(double*)malloc((ntmax+1)*sizeof(double));
      if (norms == NULL) {puts("compute_stepsize_2: error 2"); exit(1);}
    }
/*
  we compute the step size according to the first algorithm
*/
  dh=compute_stepsize_1_perturbation(s,nt,lxnorm,log10abserr,log10relerr);
  MakeMyFloatA(h,dh);
/*
  we compute the norms of the taylor coefficients
*/
  for (j=0; j<=nt; j++)
  {
    r=0;
    for (i=0; i<ND; i++)
    {
      fabsMyFloatA(mtmp,s[i][j]);
      MyFloatToDouble(r, mtmp);
      if (a > r) r=a;
    }
    norms[j]=r;
  }
/*
  next loop runs over the norms of the taylor coefficients, checking
  whether the summation of the taylor series (from low to high order)
  involves increasing terms. in this case, it reduces the stepsize
  accordingly.
*/
  MyFloatToDouble(hd,h);
  z=norms[0]+hd*norms[1];
  hdj=hd;
  flag=0;
  for(j=2; j<=nt; j++)
  {
    hdj *= hd;
    r=norms[j]*hdj;
    if (r <= z) continue;
/*
    we reduce hd (and hdj)
*/
    flag=1; /* to know if hd has been reduced */
    hdj=z/norms[j];
    a=pow(r/z,(double)1.e0/(double)j);
    hd /= a;

#if DEBUG_LEVEL > 1
    fprintf(stderr, "order %2d. reducing h from %14.6e to %14.6e\n",j,a*hd,hd);
#endif
  }
  if (flag == 1) MakeMyFloatA(h,hd); /* Maorong: this conversion, is ok? */
  MyFloatToDouble(rtmp,h);
  return(rtmp);
}
double double_log_MyFloat(MY_FLOAT x)
/*
 * natural log, in double precision, of a MY_FLOAT positive number.

Maorong: I've coded this function because gmp lacks of a log
function. do you agree with this code?
 */
{
  static MY_FLOAT a,tmp;
  static MY_FLOAT z,of,uf;
  double b,lx;
  int k;
  static int init=0;

  if (init == 0)
    {
      init=1;
      InitMyFloat(a);
      InitMyFloat(z);
      InitMyFloat(of);
      InitMyFloat(uf);
      InitMyFloat(tmp);

      b=0;
      MakeMyFloatA(z,b);
      b=pow((double)2,(double)LEXP2);
      MakeMyFloatA(of,b);
      b=pow((double)2,(double)(-LEXP2));
      MakeMyFloatA(uf,b);
    }

  if (MyFloatA_EQ_B(x,z))
    {
      puts("double_log_MyFloat error: zero argument");
      puts("(this is because one of the last two terms of your taylor");
      puts(" expansion is exactly zero)");
      exit(1);
    }

  AssignMyFloat(a,x);

  k=0;
  while(MyFloatA_LT_B(a,uf))
  {
    ++k;
    if(k>3000){fprintf(stderr,"double_log_MyFloat overflow: %d\n", k); exit(1);}
    MultiplyMyFloatA(tmp,a,of);
    AssignMyFloat(a,tmp);
  }
  while(MyFloatA_GT_B(a,of))
  {
    --k;
    if(k<-3000){fprintf(stderr,"double_log_MyFloat underflow: %d\n", k); exit(1);}
    MultiplyMyFloatA(tmp,a,uf);
    AssignMyFloat(a,tmp);
  }

  MyFloatToDouble(b,a);

/*
  lx stands for log(x)
*/
  lx=log(b)-(LEXP2*0.69314718055994530942)*k;

  return(lx);
}

/********************************************************************
we give empty user-defined routines, to avoid linking errors
********************************************************************/

int comp_order_other_perturbation(double lnxnorm, double log10abserr, double log10relerr)
/*
 * user defined routine for the computation of the order.
 * the user can insert the code she/he wants.
 */
{
 if(user_defined_order_function) {return(user_defined_order_function(lnxnorm,log10abserr,log10relerr));}
 else {
  puts("---");
  puts("compute_order_user_defined:");
  puts("you have to code this routine");
  puts("or select a different value for the step_ctl parameter");
  puts("---");
  exit(1);

  return(0);
 }
}
double comp_stepsize_other_perturbation(MY_FLOAT **s, int nd, int nt, double lxnorm, double log10abserr, double log10relerr)
/*
 * user defined routine for the computation of the step size.
 * the user can insert the code she/he wants.
 */
{
 if(user_defined_stepsize_function) {return(user_defined_stepsize_function(s,nd,nt,lxnorm,log10abserr,log10relerr));}
 else {
  puts("---");
  puts("compute_timestep_user_defined:");
  puts("you have to code this routine");
  puts("or select a different value for the step_ctl parameter");
  puts("---");
  exit(1);
  return((double)0.00001);
 }
}


/***********************************************************************
 *
 * Procedure generated by the TAYLOR translator. Do not edit!
 *
 * It needs the header file 'taylor.h' to compile.
 * Run taylor with the -header -o taylor.h option to generate a sample 'taylor.h'

 * Translation info is at the end of this file.
 *  Version Version 1.3, Oct 11, 2001
 ***********************************************************************/

#include <stdio.h>
#include <stdlib.h>
MY_FLOAT **taylor_coefficients_perturbationA(MY_FLOAT t, MY_FLOAT *x, int order, int rflag)
{
    extern MY_FLOAT e1;
    extern MY_FLOAT e2;
    extern MY_FLOAT coef[10];
    extern MY_FLOAT freq[10];

    static int          ivars[10];
    static MY_FLOAT     *jet[56],  *save = NULL, *oneOverN=NULL;
    static MY_FLOAT     tvar1, tvar2, tvar3, tvar4; /* tmp vars */
    static MY_FLOAT     uvar1, uvar2; /* tmp vars */
    static MY_FLOAT     svar1, svar2, svar3, svar4, svar5; /* tmp vars */
    static MY_FLOAT     wvar3, wvar4; /* tmp vars */
    static MY_FLOAT     zvar1, zvar2; /* tmp vars */
    static MY_FLOAT     MyFloatZERO;
    static int          maxOrderUsed  = -1;
    static int          lastOrder = 0, initialized=0, ginitialized=0;
    int                 i, j, k, l, m, n, oorder ;
    /* allocating memory if needed */
    if(maxOrderUsed < order )  { 
    	 if(ginitialized == 0) { 
    	   InitMyFloat(tvar1); InitMyFloat(tvar2);InitMyFloat(tvar3);InitMyFloat(tvar4);
    	   InitMyFloat(svar1); InitMyFloat(svar2);InitMyFloat(svar3);InitMyFloat(svar4);
    	   InitMyFloat(svar5); InitMyFloat(zvar1);InitMyFloat(zvar2);
    	   InitMyFloat(uvar1); InitMyFloat(uvar2);
    	   InitMyFloat(wvar3);InitMyFloat(wvar4);
    	   InitMyFloat(MyFloatZERO);
    	   MakeMyFloatA(MyFloatZERO, (double)0);
    	 }
    	 if(rflag > 0) rflag = 0; /* have to recompute everything */
    	 oorder=maxOrderUsed;
    	 maxOrderUsed  = order;
    	 if(ginitialized) { 
    	   for(i=0; i< oorder+1; i++) {ClearMyFloat(oneOverN[i]);} free(oneOverN);
    	 }
    	 oneOverN = (MY_FLOAT *)malloc((order+1) * sizeof(MY_FLOAT));
    	 for(i=0; i<order+1; i++) {InitMyFloat(oneOverN[i]);}
    	 MakeMyFloatA(oneOverN[0], (double)1.0);
    	 for(i = 1; i <= order; i++) {
    		 MakeMyFloatA(tvar1, (double)i);
    		 DivideMyFloatA(oneOverN[i], oneOverN[0], tvar1);
	}
    	 if(ginitialized) {
    	    for(i=0; i<(oorder+1)*(56); i++) { ClearMyFloat(save[i]);} free(save);
    	 }
    	 save = (MY_FLOAT *)malloc((order+1)* 56 *sizeof(MY_FLOAT));
    	 for(i=0; i<(order+1)*(56); i++) { InitMyFloat(save[i]);}
    	 for(j = 0, k = 0; j < 56 ;  j++, k += order+1) { jet[j] =& (save[k]); }
    	 /* nonautonomous, derivatves of time */
    	 MakeMyFloatA(jet[2][1], (double)1.0);
    	 for(i = 2; i <= order; i++) { MakeMyFloatA(jet[2][i], (double)0.0);}

    	 /* True constants, initialized only once. */
	 /* const: i_019=0 */
	 ivars[0]=0;
	 /* const: i_026=1 */
	 ivars[1]=1;
	 /* const: i_027=2 */
	 ivars[2]=2;
	 /* const: i_028=3 */
	 ivars[3]=3;
	 /* const: i_029=4 */
	 ivars[4]=4;
	 /* const: i_030=5 */
	 ivars[5]=5;
	 /* const: i_031=6 */
	 ivars[6]=6;
	 /* const: i_032=7 */
	 ivars[7]=7;
	 /* const: i_033=8 */
	 ivars[8]=8;
	 /* const: i_024=9 */
	 ivars[9]=9;
    }

    if(rflag) {
    	 if(rflag < 0 ) return(NULL);
    	 if(MyFloatA_NEQ_B(t, jet[2][0])) rflag = 0;
    	 for(i = 0; rflag != 0 && i < 2; i++) {
    		 if(MyFloatA_NEQ_B(jet[i][0], x[i])) rflag = 0;
    	 }
    }

    if(rflag == 0) {
	 /* initialize all constant vars and state variables */
	 lastOrder = 1;
	 AssignMyFloat(jet[0][0], x[0]);
	 AssignMyFloat(jet[1][0], x[1]);
	 AssignMyFloat(jet[2][0], t); /* nonautonomous, time */
	 /* mult: v_035=(e1*v_017) */
	 MultiplyMyFloatA(jet[3][0], e1, jet[1][0]);
	 /* mult: v_036=(freq[i_019]*v_018) */
	 MultiplyMyFloatA(jet[4][0], freq[ivars[0]], jet[2][0]);
	 /* call: v_037=sin(v_036) */
	 sinMyFloatA(jet[5][0], jet[4][0]);
	 /* call: v_078=cos(v_036) */
	 cosMyFloatA(jet[6][0], jet[4][0]);
	 /* mult: v_038=(coef[i_019]*v_037) */
	 MultiplyMyFloatA(jet[7][0], coef[ivars[0]], jet[5][0]);
	 /* mult: v_039=(freq[i_026]*v_018) */
	 MultiplyMyFloatA(jet[8][0], freq[ivars[1]], jet[2][0]);
	 /* call: v_040=sin(v_039) */
	 sinMyFloatA(jet[9][0], jet[8][0]);
	 /* call: v_079=cos(v_039) */
	 cosMyFloatA(jet[10][0], jet[8][0]);
	 /* mult: v_041=(coef[i_026]*v_040) */
	 MultiplyMyFloatA(jet[11][0], coef[ivars[1]], jet[9][0]);
	 /* plus: v_042=(v_038+v_041) */
	 AddMyFloatA(jet[12][0], jet[7][0], jet[11][0]);
	 /* mult: v_043=(freq[i_027]*v_018) */
	 MultiplyMyFloatA(jet[13][0], freq[ivars[2]], jet[2][0]);
	 /* call: v_044=sin(v_043) */
	 sinMyFloatA(jet[14][0], jet[13][0]);
	 /* call: v_080=cos(v_043) */
	 cosMyFloatA(jet[15][0], jet[13][0]);
	 /* mult: v_045=(coef[i_027]*v_044) */
	 MultiplyMyFloatA(jet[16][0], coef[ivars[2]], jet[14][0]);
	 /* plus: v_046=(v_042+v_045) */
	 AddMyFloatA(jet[17][0], jet[12][0], jet[16][0]);
	 /* mult: v_047=(freq[i_028]*v_018) */
	 MultiplyMyFloatA(jet[18][0], freq[ivars[3]], jet[2][0]);
	 /* call: v_048=sin(v_047) */
	 sinMyFloatA(jet[19][0], jet[18][0]);
	 /* call: v_081=cos(v_047) */
	 cosMyFloatA(jet[20][0], jet[18][0]);
	 /* mult: v_049=(coef[i_028]*v_048) */
	 MultiplyMyFloatA(jet[21][0], coef[ivars[3]], jet[19][0]);
	 /* plus: v_050=(v_046+v_049) */
	 AddMyFloatA(jet[22][0], jet[17][0], jet[21][0]);
	 /* mult: v_051=(freq[i_029]*v_018) */
	 MultiplyMyFloatA(jet[23][0], freq[ivars[4]], jet[2][0]);
	 /* call: v_052=sin(v_051) */
	 sinMyFloatA(jet[24][0], jet[23][0]);
	 /* call: v_082=cos(v_051) */
	 cosMyFloatA(jet[25][0], jet[23][0]);
	 /* mult: v_053=(coef[i_029]*v_052) */
	 MultiplyMyFloatA(jet[26][0], coef[ivars[4]], jet[24][0]);
	 /* plus: v_054=(v_050+v_053) */
	 AddMyFloatA(jet[27][0], jet[22][0], jet[26][0]);
	 /* mult: v_055=(freq[i_030]*v_018) */
	 MultiplyMyFloatA(jet[28][0], freq[ivars[5]], jet[2][0]);
	 /* call: v_056=sin(v_055) */
	 sinMyFloatA(jet[29][0], jet[28][0]);
	 /* call: v_083=cos(v_055) */
	 cosMyFloatA(jet[30][0], jet[28][0]);
	 /* mult: v_057=(coef[i_030]*v_056) */
	 MultiplyMyFloatA(jet[31][0], coef[ivars[5]], jet[29][0]);
	 /* plus: v_058=(v_054+v_057) */
	 AddMyFloatA(jet[32][0], jet[27][0], jet[31][0]);
	 /* mult: v_059=(freq[i_031]*v_018) */
	 MultiplyMyFloatA(jet[33][0], freq[ivars[6]], jet[2][0]);
	 /* call: v_060=sin(v_059) */
	 sinMyFloatA(jet[34][0], jet[33][0]);
	 /* call: v_084=cos(v_059) */
	 cosMyFloatA(jet[35][0], jet[33][0]);
	 /* mult: v_061=(coef[i_031]*v_060) */
	 MultiplyMyFloatA(jet[36][0], coef[ivars[6]], jet[34][0]);
	 /* plus: v_062=(v_058+v_061) */
	 AddMyFloatA(jet[37][0], jet[32][0], jet[36][0]);
	 /* mult: v_063=(freq[i_032]*v_018) */
	 MultiplyMyFloatA(jet[38][0], freq[ivars[7]], jet[2][0]);
	 /* call: v_064=sin(v_063) */
	 sinMyFloatA(jet[39][0], jet[38][0]);
	 /* call: v_085=cos(v_063) */
	 cosMyFloatA(jet[40][0], jet[38][0]);
	 /* mult: v_065=(coef[i_032]*v_064) */
	 MultiplyMyFloatA(jet[41][0], coef[ivars[7]], jet[39][0]);
	 /* plus: v_066=(v_062+v_065) */
	 AddMyFloatA(jet[42][0], jet[37][0], jet[41][0]);
	 /* mult: v_067=(freq[i_033]*v_018) */
	 MultiplyMyFloatA(jet[43][0], freq[ivars[8]], jet[2][0]);
	 /* call: v_068=sin(v_067) */
	 sinMyFloatA(jet[44][0], jet[43][0]);
	 /* call: v_086=cos(v_067) */
	 cosMyFloatA(jet[45][0], jet[43][0]);
	 /* mult: v_069=(coef[i_033]*v_068) */
	 MultiplyMyFloatA(jet[46][0], coef[ivars[8]], jet[44][0]);
	 /* plus: v_070=(v_066+v_069) */
	 AddMyFloatA(jet[47][0], jet[42][0], jet[46][0]);
	 /* mult: v_071=(freq[i_024]*v_018) */
	 MultiplyMyFloatA(jet[48][0], freq[ivars[9]], jet[2][0]);
	 /* call: v_072=sin(v_071) */
	 sinMyFloatA(jet[49][0], jet[48][0]);
	 /* call: v_087=cos(v_071) */
	 cosMyFloatA(jet[50][0], jet[48][0]);
	 /* mult: v_073=(coef[i_024]*v_072) */
	 MultiplyMyFloatA(jet[51][0], coef[ivars[9]], jet[49][0]);
	 /* plus: v_074=(v_070+v_073) */
	 AddMyFloatA(jet[52][0], jet[47][0], jet[51][0]);
	 /* mult: v_075=(e2*v_074) */
	 MultiplyMyFloatA(jet[53][0], e2, jet[52][0]);
	 /* negate: v_076=(-v_016) */
	 NegateMyFloatA(jet[54][0],jet[0][0]);
	 /* plus: v_077=(v_075+v_076) */
	 AddMyFloatA(jet[55][0], jet[53][0], jet[54][0]);

	 /* the first derivative of state variables */
	 /* state variable 0: */
	 AssignMyFloat(jet[0][1], jet[3][0]);
	 /* state variable 1: */
	 AssignMyFloat(jet[1][1], jet[55][0]);
	 /* nonautonomous, time'=1 has been initialized already */
	}

	 /* compute the kth order derivatives of all vars */
	 for(k = lastOrder; k < order; k++) {
		 /* derivative for tmp variables */
		 /* mult: v_035=(e1*v_017) */
		 MultiplyMyFloatA(jet[3][k], e1, jet[1][k]);
		 /* mult: v_036=(freq[i_019]*v_018) */
		 if(k==1) {AssignMyFloat(jet[4][k], freq[ivars[0]]);}
		 else {AssignMyFloat(jet[4][k], MyFloatZERO);}
		 /* call: v_037=sin(v_036) */
		 { /* call sin cos */
			 static MY_FLOAT tmp, tmp1, tmp2;
			 if(initialized==0) {
			  InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			 }
			 MultiplyMyFloatA(tmp, oneOverN[k], freq[ivars[0]]);
			 MultiplyMyFloatA(jet[5][k], jet[6][k-1], tmp);
			 MultiplyMyFloatA(tmp2, tmp, jet[5][k-1]);
			 NegateMyFloatA(tmp1, tmp2);
			 AssignMyFloat(jet[6][k], tmp1);
		 }
		 /* call: v_078=cos(v_036) */
			 /* computed already */
		 /* mult: v_038=(coef[i_019]*v_037) */
		 MultiplyMyFloatA(jet[7][k], coef[ivars[0]], jet[5][k]);
		 /* mult: v_039=(freq[i_026]*v_018) */
		 if(k==1) {AssignMyFloat(jet[8][k], freq[ivars[1]]);}
		 else {AssignMyFloat(jet[8][k], MyFloatZERO);}
		 /* call: v_040=sin(v_039) */
		 { /* call sin cos */
			 static MY_FLOAT tmp, tmp1, tmp2;
			 if(initialized==0) {
			  InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			 }
			 MultiplyMyFloatA(tmp, oneOverN[k], freq[ivars[1]]);
			 MultiplyMyFloatA(jet[9][k], jet[10][k-1], tmp);
			 MultiplyMyFloatA(tmp2, tmp, jet[9][k-1]);
			 NegateMyFloatA(tmp1, tmp2);
			 AssignMyFloat(jet[10][k], tmp1);
		 }
		 /* call: v_079=cos(v_039) */
			 /* computed already */
		 /* mult: v_041=(coef[i_026]*v_040) */
		 MultiplyMyFloatA(jet[11][k], coef[ivars[1]], jet[9][k]);
		 /* plus: v_042=(v_038+v_041) */
		 AddMyFloatA(jet[12][k], jet[7][k],jet[11][k]);
		 /* mult: v_043=(freq[i_027]*v_018) */
		 if(k==1) {AssignMyFloat(jet[13][k], freq[ivars[2]]);}
		 else {AssignMyFloat(jet[13][k], MyFloatZERO);}
		 /* call: v_044=sin(v_043) */
		 { /* call sin cos */
			 static MY_FLOAT tmp, tmp1, tmp2;
			 if(initialized==0) {
			  InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			 }
			 MultiplyMyFloatA(tmp, oneOverN[k], freq[ivars[2]]);
			 MultiplyMyFloatA(jet[14][k], jet[15][k-1], tmp);
			 MultiplyMyFloatA(tmp2, tmp, jet[14][k-1]);
			 NegateMyFloatA(tmp1, tmp2);
			 AssignMyFloat(jet[15][k], tmp1);
		 }
		 /* call: v_080=cos(v_043) */
			 /* computed already */
		 /* mult: v_045=(coef[i_027]*v_044) */
		 MultiplyMyFloatA(jet[16][k], coef[ivars[2]], jet[14][k]);
		 /* plus: v_046=(v_042+v_045) */
		 AddMyFloatA(jet[17][k], jet[12][k],jet[16][k]);
		 /* mult: v_047=(freq[i_028]*v_018) */
		 if(k==1) {AssignMyFloat(jet[18][k], freq[ivars[3]]);}
		 else {AssignMyFloat(jet[18][k], MyFloatZERO);}
		 /* call: v_048=sin(v_047) */
		 { /* call sin cos */
			 static MY_FLOAT tmp, tmp1, tmp2;
			 if(initialized==0) {
			  InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			 }
			 MultiplyMyFloatA(tmp, oneOverN[k], freq[ivars[3]]);
			 MultiplyMyFloatA(jet[19][k], jet[20][k-1], tmp);
			 MultiplyMyFloatA(tmp2, tmp, jet[19][k-1]);
			 NegateMyFloatA(tmp1, tmp2);
			 AssignMyFloat(jet[20][k], tmp1);
		 }
		 /* call: v_081=cos(v_047) */
			 /* computed already */
		 /* mult: v_049=(coef[i_028]*v_048) */
		 MultiplyMyFloatA(jet[21][k], coef[ivars[3]], jet[19][k]);
		 /* plus: v_050=(v_046+v_049) */
		 AddMyFloatA(jet[22][k], jet[17][k],jet[21][k]);
		 /* mult: v_051=(freq[i_029]*v_018) */
		 if(k==1) {AssignMyFloat(jet[23][k], freq[ivars[4]]);}
		 else {AssignMyFloat(jet[23][k], MyFloatZERO);}
		 /* call: v_052=sin(v_051) */
		 { /* call sin cos */
			 static MY_FLOAT tmp, tmp1, tmp2;
			 if(initialized==0) {
			  InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			 }
			 MultiplyMyFloatA(tmp, oneOverN[k], freq[ivars[4]]);
			 MultiplyMyFloatA(jet[24][k], jet[25][k-1], tmp);
			 MultiplyMyFloatA(tmp2, tmp, jet[24][k-1]);
			 NegateMyFloatA(tmp1, tmp2);
			 AssignMyFloat(jet[25][k], tmp1);
		 }
		 /* call: v_082=cos(v_051) */
			 /* computed already */
		 /* mult: v_053=(coef[i_029]*v_052) */
		 MultiplyMyFloatA(jet[26][k], coef[ivars[4]], jet[24][k]);
		 /* plus: v_054=(v_050+v_053) */
		 AddMyFloatA(jet[27][k], jet[22][k],jet[26][k]);
		 /* mult: v_055=(freq[i_030]*v_018) */
		 if(k==1) {AssignMyFloat(jet[28][k], freq[ivars[5]]);}
		 else {AssignMyFloat(jet[28][k], MyFloatZERO);}
		 /* call: v_056=sin(v_055) */
		 { /* call sin cos */
			 static MY_FLOAT tmp, tmp1, tmp2;
			 if(initialized==0) {
			  InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			 }
			 MultiplyMyFloatA(tmp, oneOverN[k], freq[ivars[5]]);
			 MultiplyMyFloatA(jet[29][k], jet[30][k-1], tmp);
			 MultiplyMyFloatA(tmp2, tmp, jet[29][k-1]);
			 NegateMyFloatA(tmp1, tmp2);
			 AssignMyFloat(jet[30][k], tmp1);
		 }
		 /* call: v_083=cos(v_055) */
			 /* computed already */
		 /* mult: v_057=(coef[i_030]*v_056) */
		 MultiplyMyFloatA(jet[31][k], coef[ivars[5]], jet[29][k]);
		 /* plus: v_058=(v_054+v_057) */
		 AddMyFloatA(jet[32][k], jet[27][k],jet[31][k]);
		 /* mult: v_059=(freq[i_031]*v_018) */
		 if(k==1) {AssignMyFloat(jet[33][k], freq[ivars[6]]);}
		 else {AssignMyFloat(jet[33][k], MyFloatZERO);}
		 /* call: v_060=sin(v_059) */
		 { /* call sin cos */
			 static MY_FLOAT tmp, tmp1, tmp2;
			 if(initialized==0) {
			  InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			 }
			 MultiplyMyFloatA(tmp, oneOverN[k], freq[ivars[6]]);
			 MultiplyMyFloatA(jet[34][k], jet[35][k-1], tmp);
			 MultiplyMyFloatA(tmp2, tmp, jet[34][k-1]);
			 NegateMyFloatA(tmp1, tmp2);
			 AssignMyFloat(jet[35][k], tmp1);
		 }
		 /* call: v_084=cos(v_059) */
			 /* computed already */
		 /* mult: v_061=(coef[i_031]*v_060) */
		 MultiplyMyFloatA(jet[36][k], coef[ivars[6]], jet[34][k]);
		 /* plus: v_062=(v_058+v_061) */
		 AddMyFloatA(jet[37][k], jet[32][k],jet[36][k]);
		 /* mult: v_063=(freq[i_032]*v_018) */
		 if(k==1) {AssignMyFloat(jet[38][k], freq[ivars[7]]);}
		 else {AssignMyFloat(jet[38][k], MyFloatZERO);}
		 /* call: v_064=sin(v_063) */
		 { /* call sin cos */
			 static MY_FLOAT tmp, tmp1, tmp2;
			 if(initialized==0) {
			  InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			 }
			 MultiplyMyFloatA(tmp, oneOverN[k], freq[ivars[7]]);
			 MultiplyMyFloatA(jet[39][k], jet[40][k-1], tmp);
			 MultiplyMyFloatA(tmp2, tmp, jet[39][k-1]);
			 NegateMyFloatA(tmp1, tmp2);
			 AssignMyFloat(jet[40][k], tmp1);
		 }
		 /* call: v_085=cos(v_063) */
			 /* computed already */
		 /* mult: v_065=(coef[i_032]*v_064) */
		 MultiplyMyFloatA(jet[41][k], coef[ivars[7]], jet[39][k]);
		 /* plus: v_066=(v_062+v_065) */
		 AddMyFloatA(jet[42][k], jet[37][k],jet[41][k]);
		 /* mult: v_067=(freq[i_033]*v_018) */
		 if(k==1) {AssignMyFloat(jet[43][k], freq[ivars[8]]);}
		 else {AssignMyFloat(jet[43][k], MyFloatZERO);}
		 /* call: v_068=sin(v_067) */
		 { /* call sin cos */
			 static MY_FLOAT tmp, tmp1, tmp2;
			 if(initialized==0) {
			  InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			 }
			 MultiplyMyFloatA(tmp, oneOverN[k], freq[ivars[8]]);
			 MultiplyMyFloatA(jet[44][k], jet[45][k-1], tmp);
			 MultiplyMyFloatA(tmp2, tmp, jet[44][k-1]);
			 NegateMyFloatA(tmp1, tmp2);
			 AssignMyFloat(jet[45][k], tmp1);
		 }
		 /* call: v_086=cos(v_067) */
			 /* computed already */
		 /* mult: v_069=(coef[i_033]*v_068) */
		 MultiplyMyFloatA(jet[46][k], coef[ivars[8]], jet[44][k]);
		 /* plus: v_070=(v_066+v_069) */
		 AddMyFloatA(jet[47][k], jet[42][k],jet[46][k]);
		 /* mult: v_071=(freq[i_024]*v_018) */
		 if(k==1) {AssignMyFloat(jet[48][k], freq[ivars[9]]);}
		 else {AssignMyFloat(jet[48][k], MyFloatZERO);}
		 /* call: v_072=sin(v_071) */
		 { /* call sin cos */
			 static MY_FLOAT tmp, tmp1, tmp2;
			 if(initialized==0) {
			  InitMyFloat(tmp1);InitMyFloat(tmp2); InitMyFloat(tmp);
			 }
			 MultiplyMyFloatA(tmp, oneOverN[k], freq[ivars[9]]);
			 MultiplyMyFloatA(jet[49][k], jet[50][k-1], tmp);
			 MultiplyMyFloatA(tmp2, tmp, jet[49][k-1]);
			 NegateMyFloatA(tmp1, tmp2);
			 AssignMyFloat(jet[50][k], tmp1);
		 }
		 /* call: v_087=cos(v_071) */
			 /* computed already */
		 /* mult: v_073=(coef[i_024]*v_072) */
		 MultiplyMyFloatA(jet[51][k], coef[ivars[9]], jet[49][k]);
		 /* plus: v_074=(v_070+v_073) */
		 AddMyFloatA(jet[52][k], jet[47][k],jet[51][k]);
		 /* mult: v_075=(e2*v_074) */
		 MultiplyMyFloatA(jet[53][k], e2, jet[52][k]);
		 /* negation: v_076=(-v_016) */
		 NegateMyFloatA(jet[54][k], jet[0][k]);
		 /* plus: v_077=(v_075+v_076) */
		 AddMyFloatA(jet[55][k], jet[53][k],jet[54][k]);
		 /* derivative of state variables */
		 m = k+1;
		 /* state variable 0: */
		 MultiplyMyFloatA(jet[0][m], jet[3][k], oneOverN[m]);
		 /* state variable 1: */
		 MultiplyMyFloatA(jet[1][m], jet[55][k], oneOverN[m]);
		 initialized=1;
	 }
    lastOrder = order;
    ginitialized=1;
    return(jet);
}
MY_FLOAT **taylor_coefficients_perturbation(MY_FLOAT t, MY_FLOAT *x, int order)
{
    return(taylor_coefficients_perturbationA(t,x,order,0));
}

/******************** Translation Info *****************************/
/*


===================================================================================
=======                                                                      ======
=======                         Final Variable List                          ======
	    (56 + 0) vars, (0 + 0) cvars and (10 + 0) ivars 
=======                                                                      ======
===================================================================================
	v_016 (state variable)
	v_017 (state variable)
	v_018 (time)
	v_035 = (e1*v_017)                               (3 0)
	i_019 = 0                                        (0 0) (a number)
	v_036 = (freq[i_019]*v_018)                      (4 0)
	v_037 = sin(v_036)                               (5 0)
	v_078 = cos(v_036)                               (6 0)
	v_038 = (coef[i_019]*v_037)                      (7 0)
	i_026 = 1                                        (1 0) (a number)
	v_039 = (freq[i_026]*v_018)                      (8 0)
	v_040 = sin(v_039)                               (9 0)
	v_079 = cos(v_039)                               (10 0)
	v_041 = (coef[i_026]*v_040)                      (11 0)
	v_042 = (v_038+v_041)                            (12 0)
	i_027 = 2                                        (2 0) (a number)
	v_043 = (freq[i_027]*v_018)                      (13 0)
	v_044 = sin(v_043)                               (14 0)
	v_080 = cos(v_043)                               (15 0)
	v_045 = (coef[i_027]*v_044)                      (16 0)
	v_046 = (v_042+v_045)                            (17 0)
	i_028 = 3                                        (3 0) (a number)
	v_047 = (freq[i_028]*v_018)                      (18 0)
	v_048 = sin(v_047)                               (19 0)
	v_081 = cos(v_047)                               (20 0)
	v_049 = (coef[i_028]*v_048)                      (21 0)
	v_050 = (v_046+v_049)                            (22 0)
	i_029 = 4                                        (4 0) (a number)
	v_051 = (freq[i_029]*v_018)                      (23 0)
	v_052 = sin(v_051)                               (24 0)
	v_082 = cos(v_051)                               (25 0)
	v_053 = (coef[i_029]*v_052)                      (26 0)
	v_054 = (v_050+v_053)                            (27 0)
	i_030 = 5                                        (5 0) (a number)
	v_055 = (freq[i_030]*v_018)                      (28 0)
	v_056 = sin(v_055)                               (29 0)
	v_083 = cos(v_055)                               (30 0)
	v_057 = (coef[i_030]*v_056)                      (31 0)
	v_058 = (v_054+v_057)                            (32 0)
	i_031 = 6                                        (6 0) (a number)
	v_059 = (freq[i_031]*v_018)                      (33 0)
	v_060 = sin(v_059)                               (34 0)
	v_084 = cos(v_059)                               (35 0)
	v_061 = (coef[i_031]*v_060)                      (36 0)
	v_062 = (v_058+v_061)                            (37 0)
	i_032 = 7                                        (7 0) (a number)
	v_063 = (freq[i_032]*v_018)                      (38 0)
	v_064 = sin(v_063)                               (39 0)
	v_085 = cos(v_063)                               (40 0)
	v_065 = (coef[i_032]*v_064)                      (41 0)
	v_066 = (v_062+v_065)                            (42 0)
	i_033 = 8                                        (8 0) (a number)
	v_067 = (freq[i_033]*v_018)                      (43 0)
	v_068 = sin(v_067)                               (44 0)
	v_086 = cos(v_067)                               (45 0)
	v_069 = (coef[i_033]*v_068)                      (46 0)
	v_070 = (v_066+v_069)                            (47 0)
	i_024 = 9                                        (9 0) (a number)
	v_071 = (freq[i_024]*v_018)                      (48 0)
	v_072 = sin(v_071)                               (49 0)
	v_087 = cos(v_071)                               (50 0)
	v_073 = (coef[i_024]*v_072)                      (51 0)
	v_074 = (v_070+v_073)                            (52 0)
	v_075 = (e2*v_074)                               (53 0)
	v_076 = (-v_016)                                 (54 0)
	v_077 = (v_075+v_076)                            (55 0)
===================================================================
=========                                                  ========
=========          Differential Equations                  ========
=========                                                  ========
===================================================================

	 v_016'=v_035
	 v_017'=v_077
	 v_018'=v_020
*/
/*************** END  END  END ***************************************/
