/*********************************************************************
 *
 *       Taylor  
 *
 *    Copyright (C) 1999  Maorong Zou, Angel Jorba
 *
 *
 *  This file is part of taylor.
 *
 * Taylor is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * Taylor is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Taylor; see the file COPYING.  If not, write to
 * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
 *
 *************************************************************************/
#include "Header.h"
#include "OneStep.h"
#include "OneStepF77.h"
/************************************************************************
 *
 * search for word in buf. Return 1 if found.
 * if pos_ret is not NULL, it returns the starting
 * location of the match.
 */
int matchWord(buf, word, buflen, pos_ret) 
     char *buf; char *word; int *pos_ret, buflen;
{
  int blen, wlen;
  int pfxS[256], *pfx = pfxS;

  blen = buflen;
  wlen = strlen(word);
  if(blen < wlen) return(0);
  if(wlen > 250)  pfx = (int *) malloc( (wlen + 4) * sizeof(int));

  /* compute the prefix function */
  {
    int m = wlen;
    int i,j;
    pfx[0] = -2;
    pfx[1] = -1;
    for(i = 2; i < m; i++)
      {
	j = pfx[i-1] + 1;
	while(word[i-1] != word[j] && j >= 0) j = pfx[j]+1;
	pfx[i] = j;
      }
  }

  /* match */
  {
    int n = blen;
    int m = wlen;
    int i=0, j=0;

    while(i < n)
      {
	if(word[j] == buf[i]) {j++; i++;}
	else 
	  {
	    j = pfx[j] + 1;
	    if(j < 0) {j = 0; i++;}
	  }
	if(j == m)
	  {
	    if(pos_ret) *pos_ret = i-m;
	    if(pfx != pfxS) free(pfx);
	    return(1);
	  }
      }
  }
  if(pfx != pfxS) free(pfx);
  return(0);
}
/***************************************************************************/


void genMainCode()
{
  int i,j, nsteps=0, stoptime=0; 
  double dtmp;

  fprintf(outfile,"/***********************************************************************\n");
  fprintf(outfile," *\n");
  fprintf(outfile," * Code generated by the TAYLOR translator.\n");
  fprintf(outfile," */\n\n");

  fprintf(outfile,"main(int argc, char **argv)\n{\n");

  fprintf(outfile,"\t int       i, j, order=20, itmp=0, direction = 1, nsteps = -1;\n");
  fprintf(outfile,"\t double    ftmp, dstep, tolerance, rtolerance, log10tolerance, log10rtolerance;\n");
  fprintf(outfile,"\t MY_FLOAT  startT, stopT, nextT;\n");
  fprintf(outfile,"\t MY_FLOAT  myFloatZero;\n");
  j = neqns + 1;
  fprintf(outfile,"\t MY_FLOAT  xx[%d], yy[%d], zz[%d];\n", j,j,j);
  fprintf(outfile,"\t MY_FLOAT  **jet;\n");
  if(qd2 | qd4 ) {
    fprintf(outfile,"\t unsigned int old_cw;;\n");    
    fprintf(outfile,"\t fpu_fix_start(&old_cw);\n");    
  } else if(gmp) {
    if( gmp_precision ) {
      fprintf(outfile, "\t mpf_set_default_prec(%d);\n", gmp_precision);
    } else {
 fprintf(outfile, "{ int gmppre;\n");
 fprintf(outfile, "fprintf(stderr, \"Enter gmp precision in number of bits: \");\n");
 fprintf(outfile, "scanf(\"%%d\", &gmppre);\n");      
 fprintf(outfile, "\t mpf_set_default_prec(gmppre);\n"); 
 fprintf(outfile, "};\n"); 
    }
  } else if(mpfr) {
    if( mpfr_precision ) {
      fprintf(outfile, "\t mpfr_set_default_prec(%d);\n", mpfr_precision);
    } else {
 fprintf(outfile, "{ int gmppre;\n");
 fprintf(outfile, "fprintf(stderr, \"Enter mpfr precision in number of bits: \");\n");
 fprintf(outfile, "scanf(\"%%d\", &gmppre);\n");      
 fprintf(outfile, "\t mpfr_set_default_prec(gmppre);\n"); 
 fprintf(outfile, "};\n"); 
    }
  } else if(ddouble) {fprintf(outfile, "\t cout <<setprecision(31);\n");}
  fprintf(outfile, "\t InitMyFloat(myFloatZero);\n");
  fprintf(outfile, "\t InitMyFloat(startT);\n");
  fprintf(outfile, "\t InitMyFloat(stopT);\n");
  fprintf(outfile, "\t InitMyFloat(nextT);\n");
  fprintf(outfile, "\t for(i=0; i<%d; i++){InitMyFloat(xx[i]); InitMyFloat(yy[i]);InitMyFloat(zz[i]);}\n",j);
  fprintf(outfile,"\n\t MakeMyFloatA(myFloatZero, 0);\n");
  
  fprintf(outfile, "\n\t /* assign initials */\n");
  if(controlParams.ninitials > 0)
    {
      int cnt;
      if(controlParams.ninitials != neqns - nonautonomous)
        fprintf(stderr, "Warning: number of initial values does not match number of equations!\n");
      if(controlParams.ninitials > neqns - nonautonomous)
        cnt = neqns - nonautonomous;
      else cnt = controlParams.ninitials;
      for(i = 0; i < cnt; i++)
        {
          double dtmp = cstNodeValue(controlParams.initials[i]);
          fprintf(outfile,"\t MakeMyFloatC(xx[%d],\"%.10g\", (double)%.10g);\n", i, dtmp, dtmp);
        }
    }
  else
    {
      for(i = 0; i < neqns-nonautonomous; i++)
        {
          fprintf(outfile,"\t fprintf(stderr,\"Enter Initial xx[%d]: \"); \n",i);
          fprintf(outfile,"\t scanf(\"%%le\", &ftmp);");
          fprintf(outfile,"\t MakeMyFloatA(xx[%d], (double)ftmp );\n", i);
        }
    }

  if(getControlParameterValue("numberOfSteps",&dtmp) || getControlParameterValue("number_of_steps",&dtmp)||
     getControlParameterValue("NumberOfSteps",&dtmp) || getControlParameterValue("Number_Of_Steps",&dtmp))
    {
      nsteps = 1;
      fprintf(outfile,"\t nsteps = %d;\n", (int)dtmp);
      fprintf(outfile,"\t if(nsteps <0) nsteps = -nsteps;;\n");
    }
  if(getControlParameterValue("stopTime",&dtmp) || getControlParameterValue("stop_time",&dtmp)||
     getControlParameterValue("StopTime",&dtmp) || getControlParameterValue("Stop_Time",&dtmp))
    {
      stoptime=1;
      fprintf(outfile,"\t MakeMyFloatC(stopT, \"%.10g\", (double)(%.10g));\n", dtmp, dtmp);      
    }
  /* start time */
  if(getControlParameterValue("startTime",&dtmp) || getControlParameterValue("start_time",&dtmp)||
     getControlParameterValue("StartTime",&dtmp) || getControlParameterValue("Start_Time",&dtmp))
    {
      fprintf(outfile,"\t MakeMyFloatC(startT, \"%.10g\", (double)(%.10g));\n",dtmp, dtmp);      
    }
  else
    {
      fprintf(outfile,"\t fprintf(stderr,\"Enter start time: \"); \n");
      fprintf(outfile,"\t scanf(\"%%le\", &dstep);");
      fprintf(outfile,"\t MakeMyFloatA(startT, dstep);\n");
    }
  /* make sure we have a stop condition */
  if(nsteps <= 0 && stoptime == 0) 
    {
      stoptime = 1;
      fprintf(outfile,"\t fprintf(stderr,\"Enter stop time: \"); \n");
      fprintf(outfile,"\t scanf(\"%%le\", &dstep);");
      fprintf(outfile,"\t MakeMyFloatA(stopT, dstep);\n");
    }
  if(getControlParameterValue("minimalStep",&dtmp) || getControlParameterValue("minimal_step",&dtmp)||
     getControlParameterValue("MinimalStep",&dtmp) || getControlParameterValue("Minimal_Step",&dtmp)||
     getControlParameterValue("maximalStep",&dtmp) || getControlParameterValue("maximal_step",&dtmp)||
     getControlParameterValue("MaximalStep",&dtmp) || getControlParameterValue("Maximal_Step",&dtmp)||
     getControlParameterValue("step",&dtmp) || getControlParameterValue("Step",&dtmp)||
     getControlParameterValue("StepSize",&dtmp) || getControlParameterValue("step_size",&dtmp)||
     getControlParameterValue("stepSize",&dtmp) || getControlParameterValue("Step_Size",&dtmp))
    {
      fprintf(outfile,"\t MakeMyFloatC(nextT, \"%.10g\", (double)(%.10g) );\n", dtmp, dtmp);
      fprintf(outfile,"\t dstep = (double)%.10g;\n", dtmp);      
    }
  else 
    {
      fprintf(outfile, "\t dstep=0.001; /* only nedeed when step_ctrl_method==0 (see manual) */\n");
      fprintf(outfile,"\t MakeMyFloatA(nextT, (double)dstep);\n");
    }
  /* get max error tolerance */
  if(getControlParameterValue("absoluteErrorTolerance",&dtmp) || getControlParameterValue("absolute_error_tolerance",&dtmp)||
     getControlParameterValue("AbsoluteErrorTolerance",&dtmp) || getControlParameterValue("Absolute_Error_Tolerance",&dtmp))
    {
      fprintf(outfile,"\t tolerance = (double)(%.10g);\n",dtmp);      
    }
  else 
    {
      fprintf(outfile,"\t fprintf(stderr,\"Enter absolute error tolerance: \"); \n");
      fprintf(outfile,"\t scanf(\"%%le\", &tolerance);");
    }
  if(getControlParameterValue("relativeErrorTolerance",&dtmp) || getControlParameterValue("relative_error_tolerance",&dtmp)||
     getControlParameterValue("RelativeErrorTolerance",&dtmp) || getControlParameterValue("Relative_Error_Tolerance",&dtmp))
    {
      fprintf(outfile,"\t rtolerance = (double)(%.10g);\n",dtmp);      
    }
  else 
    {
      fprintf(outfile,"\n\t fprintf(stderr,\"Enter relative error tolerance: \"); \n");
      fprintf(outfile,"\t scanf(\"%%le\", &rtolerance);");
    }

  fprintf(outfile, "\n");  
  fprintf(outfile, "\t log10tolerance  = log10(tolerance);\n");
  fprintf(outfile, "\t log10rtolerance = log10(rtolerance);\n");

  fprintf(outfile, "\n\t /* the main loop */\n");  
  fprintf(outfile, "\n\t if(dstep < (double)0.0) { direction = -1;}\n");
  fprintf(outfile, "\t do  {\n");
  /* output current value first */
  if(gmp) {
    for(i=0; i < neqns-nonautonomous; i++) 
      { fprintf(outfile, "\t\t mpf_out_str(stdout, 10, 30, xx[%d]); printf(\" \");\n", i); }
    fprintf(outfile, "\t\t mpf_out_str(stdout,10,30,startT);");
    fprintf(outfile, "\t\t printf(\"\\n\");");
  } else if(mpfr) {
    for(i=0; i < neqns-nonautonomous; i++) 
      { fprintf(outfile, "\t\t mpfr_out_str(stdout, 10, 30, xx[%d],GMP_RNDN); printf(\" \");\n", i); }
    fprintf(outfile, "\t\t mpfr_out_str(stdout,10,30,startT,GMP_RNDN);");
    fprintf(outfile, "\t\t printf(\"\\n\");");
  } else {
    if(ddouble | qd2 | qd4)
      {
        fprintf(outfile, "\t\t cout << ");  
        for(i=0; i < neqns-nonautonomous; i++) fprintf(outfile, "xx[%d] << \" \" << ", i);
        fprintf(outfile, "startT << endl;\n");  
      }
    else
      {
        fprintf(outfile, "\t\t printf(\"");
        for(i=0; i < neqns-nonautonomous; i++) fprintf(outfile, "%%g ");
        fprintf(outfile, "%%g\\n\",");
        for(i=0; i < neqns-nonautonomous; i++) fprintf(outfile, "(double)xx[%d],", i);
        fprintf(outfile, "(double)startT);\n");  
      }
  }

  /* integrate one step */
  fprintf(outfile, "\n\t\t itmp = taylor_step_%s( &startT, xx, direction, %d, log10tolerance, log10rtolerance, &stopT, &nextT, &order);\n", 
          suffix, step_ctrl);

  /* check stop condition */
  if(nsteps > 0) { 
    fprintf(outfile, "\t\t nsteps--;\n");
  }
  if(nsteps > 0)
    fprintf(outfile, "\t     } while(itmp == 0 && nsteps != 0); /* while */ \n");      
  else
    fprintf(outfile, "\t     } while(itmp == 0); /* while */ \n");      
  if(qd2 | qd4 ) {
    fprintf(outfile,"\t fpu_fix_end(&old_cw);\n");    
  }
  fprintf(outfile, "\t exit(0); \n");      
  fprintf(outfile, " } \n");      
}

void genStepCode() 
{
  fprintf(outfile,"/***********************************************************************\n");
  fprintf(outfile," *\n");
  fprintf(outfile," * Code generated by the TAYLOR translator.\n");
  fprintf(outfile," */\n\n");

  fprintf(outfile, "#define _N_DIM_ %d\n", neqns - nonautonomous);
  fprintf(outfile, "\n\n");

  fprintf(outfile, "\n\n");
  /*
  fprintf(outfile, "static int (*user_defined_order_function)(double, double, double);\n");
  fprintf(outfile, "static double (*user_defined_stepsize_function)(MY_FLOAT **, int, int, double, double, double);\n");
  */
  fprintf(outfile, "\n\n");  

  /** code for step control etc **/
  {
    static char *word = "_ODE_NAME__";
    char *str = oneStepCode;
    int  length = strlen(oneStepCode);
    int  wlen = strlen(word);
    int  i, location = 0;
    while(matchWord(str, word, length, &location)) {
      for(i = 0; i < location; i++) {fputc(str[i], outfile);}
      str += location + wlen;
      length -= (location + wlen);
      fprintf(outfile, "%s", suffix);
    }
    fprintf(outfile,"%s\n", str);
  }
  /** code for use defined step control etc **/
  {
    fprintf(outfile,"int comp_order_other_%s(double lnxnorm, double log10abserr, double log10relerr){\n", suffix);
    if(uso_name) {
      fprintf(outfile, "  extern int %s(double, double, double);\n", uso_name);      
      fprintf(outfile, "  return %s(lnxnorm,log10abserr,log10relerr);\n", uso_name);      
    }
    fprintf(outfile, "\
  puts(\"---\");\n\
  puts(\"compute_order_user_defined:\");\n\
  puts(\"you have to code this routine\");\n\
  puts(\"or select a different value for the step_ctl parameter\");\n\
  puts(\"---\");\n\
  exit(1);\n\
\n\
  return(0);\n\
}\n\
");
    fprintf(outfile, "double comp_stepsize_other_%s(MY_FLOAT **s, int nd, int nt, double xnorm, double log10abserr, double log10relerr) {\n\n", suffix);
    if(uss_name) {
      fprintf(outfile, "  extern double %s(MY_FLOAT **,int,int,double,double,double);\n", uss_name);      
      fprintf(outfile, "  return %s(s,nd,nt,xnorm,log10abserr,log10relerr);\n", uss_name);
    }
    fprintf(outfile, 
"\
  puts(\"---\");\n\
  puts(\"compute_timestep_user_defined:\");\n\
  puts(\"you have to code this routine\");\n\
  puts(\"or select a different value for the step_ctl parameter\");\n\
  puts(\"---\");\n\
  exit(1);\n\
  return((double)0.00001);\n\
}\n");
  }
  if(f77hook) {
    static char *word = "_ODE_NAME__";
    char *str = OneStepCodeF77;
    int  length = strlen(OneStepCodeF77);
    int  wlen = strlen(word);
    int  i, location = 0;
    while(matchWord(str, word, length, &location)) {
      for(i = 0; i < location; i++) {fputc(str[i], outfile);}
      str += location + wlen;
      length -= (location + wlen);
      fprintf(outfile, "%s", suffix);
    }
    fprintf(outfile,"%s\n", str);
  }
}
/***************************************************************************/
